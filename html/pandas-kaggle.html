<!DOCTYPE html>
<html lang="en">
<head>
<title>Pandas (Kaggle)</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="../img/favicon.ico">
<link rel="stylesheet" href="../css/bootstrap.min.css">
</head>
<body>
<div class="container">
    <h1 class="text-center mt-5 mb-5">Pandas</h1>
    <p class="text-end mb-5"><em>Kaggle</em></p>
    <div class="accordion" id="accordionExample">
        <div class="accordion-item">
            <h2 class="accordion-header" id="headingOne">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">Creating, Reading and Writing</button>
            </h2>
            <div id="collapseOne" class="accordion-collapse collapse" aria-labelledby="headingOne" data-bs-parent="#accordionExample">
                <div class="accordion-body">
                    <p>There are two core objects in pandas: the <span class="badge rounded-pill bg-secondary">DataFrame</span> and the <span class="badge rounded-pill bg-secondary">Series</span>.</p>
                    <img src="../img/pandas-kaggle/creating-data-1.PNG" class="mx-auto d-block" alt="Creating data">
                    <p>In this example, the "0, No" entry has the value of 131. The "0, Yes" entry has a value of 50, and so on.</p>
                    <p>We are using the <span class="badge rounded-pill bg-secondary">pd.DataFrame()</span> constructor to generate these DataFrame objects. The dictionary-list constructor assigns values to the column labels, but just uses an ascending count from 0 (0, 1, 2, 3, ...) for the row labels. The list of row labels used in a DataFrame is known as an <span class="badge rounded-pill bg-secondary">Index</span>. We can assign values to it by using an index parameter in our constructor:</p>
                    <img src="../img/pandas-kaggle/creating-data-2.PNG" class="mx-auto d-block" alt="Creating data"><img src="../img/pandas-kaggle/creating-data-3.PNG" class="mx-auto d-block" alt="Creating data">
                    <p>A Series does not have a column name, it only has one overall name:</p>
                    <img src="../img/pandas-kaggle/creating-data-4.PNG" class="mx-auto d-block" alt="Creating data"><img src="../img/pandas-kaggle/reading-data-files-1.PNG" class="mx-auto d-block" alt="Reading data files">
                    <p>A CSV file is a table of values separated by commas. Hence the name: "Comma-Separated Values", or CSV.</p>
                    <img src="../img/pandas-kaggle/reading-data-files-2.PNG" class="mx-auto d-block" alt="Reading data files"><img src="../img/pandas-kaggle/reading-data-files-3.PNG" class="mx-auto d-block" alt="Reading data files"><img src="../img/pandas-kaggle/creating-reading-and-writing-exercise-1.PNG" class="mx-auto d-block" alt="Creating, reading and writing - exercise"><img src="../img/pandas-kaggle/creating-reading-and-writing-exercise-2.PNG" class="mx-auto d-block" alt="Creating, reading and writing - exercise"></div>
            </div>
        </div>
        <div class="accordion-item">
            <h2 class="accordion-header" id="headingTwo">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseTwo" aria-expanded="true" aria-controls="collapseTwo">Indexing, Selecting and Assigning</button>
            </h2>
            <div id="collapseTwo" class="accordion-collapse collapse" aria-labelledby="headingTwo" data-bs-parent="#accordionExample">
                <div class="accordion-body"><img src="../img/pandas-kaggle/native-accessors-1.PNG" class="mx-auto d-block" alt="Native accessors"><img src="../img/pandas-kaggle/native-accessors-2.PNG" class="mx-auto d-block" alt="Native accessors">
                    <p>These are the two ways of selecting a specific Series out of a DataFrame. Neither of them is more or less syntactically valid than the other, but the indexing operator [] does have the advantage that it can handle column names with reserved characters in them (e.g. if we had a country providence column, reviews.country providence wouldn't work).</p>
                    <img src="../img/pandas-kaggle/native-accessors-3.PNG" class="mx-auto d-block" alt="Native accessors">
                    <p>Pandas has its own accessor operators, loc and iloc. Pandas indexing works in one of two paradigms. The first is <span class="badge rounded-pill bg-secondary">index-based selection</span>: selecting data based on its numerical position in the data. <span class="badge rounded-pill bg-secondary">iloc</span> follows this paradigm. To select the first row of data in a DataFrame, we may use the following:</p>
                    <img src="../img/pandas-kaggle/index-based-selection-1.PNG" class="mx-auto d-block" alt="Index-based selection">
                    <p>Both loc and iloc are row-first, column-second. This is the opposite of what we do in native Python, which is column-first, row-second. To get a column with iloc, we can do the following:</p>
                    <img src="../img/pandas-kaggle/index-based-selection-2.PNG" class="mx-auto d-block" alt="Index-based selection">
                    <p>On its own, the : operator, which also comes from native Python, means "everything". When combined with other selectors, however, it can be used to indicate a range of values. To select the country column from just the first, second, and third row, we would do:</p>
                    <img src="../img/pandas-kaggle/index-based-selection-3.PNG" class="mx-auto d-block" alt="Index-based selection">
                    <p>Or, to select just the second and third entries, we would do:</p>
                    <img src="../img/pandas-kaggle/index-based-selection-4.PNG" class="mx-auto d-block" alt="Index-based selection">
                    <p>It's also possible to pass a list:</p>
                    <img src="../img/pandas-kaggle/index-based-selection-5.PNG" class="mx-auto d-block" alt="Index-based selection">
                    <p>This will start counting forwards from the end of the values:</p>
                    <img src="../img/pandas-kaggle/index-based-selection-6.PNG" class="mx-auto d-block" alt="Index-based selection">
                    <p>The second paradigm for attribute selection is the one followed by the <span class="badge rounded-pill bg-secondary">loc</span> operator: <span class="badge rounded-pill bg-secondary">label-based selection</span>. In this paradigm, it's the data index value, not its position, which matters. To get the first entry in reviews, we would now do the following:</p>
                    <img src="../img/pandas-kaggle/label-based-selection-1.PNG" class="mx-auto d-block" alt="Label-based selection"><img src="../img/pandas-kaggle/label-based-selection-2.PNG" class="mx-auto d-block" alt="Label-based selection">
                    <p>iloc uses the Python stdlib indexing scheme, where the first element of the range is included and the last one excluded (0:10 will select entries 0,...,9); loc, meanwhile, indexes inclusively (0:10 will select entries 0,...,10):</p>
                    <img src="../img/pandas-kaggle/indexing-selecting-and-assigning-exercise-1.PNG" class="mx-auto d-block" alt="Indexing, selecting and assigning - exercise"><img src="../img/pandas-kaggle/manipulating-the-index.PNG" class="mx-auto d-block" alt="Manipulating the index"><img src="../img/pandas-kaggle/conditional-selection-1.PNG" class="mx-auto d-block" alt="Conditional selection">
                    <p>This operation produced a Series of True/False booleans based on the country of each record. This result can then be used inside of loc to select the relevant data:</p>
                    <img src="../img/pandas-kaggle/conditional-selection-2.PNG" class="mx-auto d-block" alt="Conditional selection"><img src="../img/pandas-kaggle/conditional-selection-3.PNG" class="mx-auto d-block" alt="Conditional selection"><img src="../img/pandas-kaggle/conditional-selection-4.PNG" class="mx-auto d-block" alt="Conditional selection">
                    <p>Pandas comes with a few built-in conditional selectors, two of which we will highlight here. The first is <span class="badge rounded-pill bg-secondary">isin</span>:</p>
                    <img src="../img/pandas-kaggle/conditional-selection-5.PNG" class="mx-auto d-block" alt="Conditional selection">
                    <p>The second is <span class="badge rounded-pill bg-secondary">isnull</span> (and its companion <span class="badge rounded-pill bg-secondary">notnull</span>). These methods let you highlight values which are (or are not) empty (NaN):</p>
                    <img src="../img/pandas-kaggle/conditional-selection-6.PNG" class="mx-auto d-block" alt="Conditional selection"><img src="../img/pandas-kaggle/assigning-data.PNG" class="mx-auto d-block" alt="Assigning data"></div>
            </div>
        </div>
        <div class="accordion-item">
            <h2 class="accordion-header" id="headingThree">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseThree" aria-expanded="true" aria-controls="collapseThree">Summary Functions and Maps</button>
            </h2>
            <div id="collapseThree" class="accordion-collapse collapse" aria-labelledby="headingThree" data-bs-parent="#accordionExample">
                <div class="accordion-body"><img src="../img/pandas-kaggle/summary-functions-1.PNG" class="mx-auto d-block" alt="Summary functions"><img src="../img/pandas-kaggle/summary-functions-2.PNG" class="mx-auto d-block" alt="Summary functions"><img src="../img/pandas-kaggle/summary-functions-3.PNG" class="mx-auto d-block" alt="Summary functions">
                    <p>To see a list of unique values and how often they occur in the dataset, we can use the <span class="badge rounded-pill bg-secondary">value_counts()</span> method:</p>
                    <img src="../img/pandas-kaggle/summary-functions-4.PNG" class="mx-auto d-block" alt="Summary functions">
                    <p><span class="badge rounded-pill bg-secondary">map()</span> returns a new Series where all the values have been transformed by your function:</p>
                    <img src="../img/pandas-kaggle/maps-1.PNG" class="mx-auto d-block" alt="Maps"><img src="../img/pandas-kaggle/summary-functions-and-maps-exercise-1.PNG" class="mx-auto d-block" alt="Summary functions and maps - exercise"><img src="../img/pandas-kaggle/summary-functions-and-maps-exercise-2.PNG" class="mx-auto d-block" alt="Summary functions and maps - exercise">
                    <p><span class="badge rounded-pill bg-secondary">apply()</span> is the equivalent method if we want to transform a whole DataFrame by calling a custom method on each row:</p>
                    <img src="../img/pandas-kaggle/maps-2.PNG" class="mx-auto d-block" alt="Maps"><img src="../img/pandas-kaggle/summary-functions-and-maps-exercise-3.PNG" class="mx-auto d-block" alt="Summary functions and maps - exercise">
                    <p>If we had called reviews.apply() with axis='index', then instead of passing a function to transform each row, we would need to give a function to transform each column.</p>
                    <p>Note that map() and apply() return new, transformed Series and DataFrames, respectively. They don't modify the original data they're called on. If we look at the first row of reviews, we can see that it still has its original points value:</p>
                    <img src="../img/pandas-kaggle/maps-3.PNG" class="mx-auto d-block" alt="Maps">
                    <p>Pandas provides many common mapping operations as built-ins. Here's a faster way of remeaning our points column:</p>
                    <img src="../img/pandas-kaggle/maps-4.PNG" class="mx-auto d-block" alt="Maps">
                    <p>In this code we are performing an operation between a lot of values on the left-hand side (everything in the Series) and a single value on the right-hand side (the mean value). Pandas will also understand what to do if we perform these operations between Series of equal length. An easy way of combining country and region information in the dataset would be to do the following:</p>
                    <img src="../img/pandas-kaggle/maps-5.PNG" class="mx-auto d-block" alt="Maps">
                    <p>These operators are faster than map() or apply() because they uses speed ups built into pandas. However, they are not as flexible as map() or apply(), which can do more advanced things, like applying conditional logic, which cannot be done with addition and subtraction alone.</p>
                </div>
            </div>
        </div>
        <div class="accordion-item">
            <h2 class="accordion-header" id="headingFour">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseFour" aria-expanded="true" aria-controls="collapseFour">Grouping and Sorting</button>
            </h2>
            <div id="collapseFour" class="accordion-collapse collapse" aria-labelledby="headingFour" data-bs-parent="#accordionExample">
                <div class="accordion-body"><img src="../img/pandas-kaggle/groupwise-analysis-1.PNG" class="mx-auto d-block" alt="Groupwise analysis"><img src="../img/pandas-kaggle/groupwise-analysis-2.PNG" class="mx-auto d-block" alt="Groupwise analysis"><img src="../img/pandas-kaggle/grouping-and-sorting-exercise-1.PNG" class="mx-auto d-block" alt="Grouping and sorting - exercise"><img src="../img/pandas-kaggle/grouping-and-sorting-exercise-2.PNG" class="mx-auto d-block" alt="Grouping and sorting - exercise"><img src="../img/pandas-kaggle/grouping-and-sorting-exercise-3.PNG" class="mx-auto d-block" alt="Grouping and sorting - exercise">
                    <p>You can think of each group we generate as being a slice of our DataFrame containing only data with values that match. This DataFrame is accessible to us directly using the apply() method, and we can then manipulate the data in any way we see fit. Here's how we would pick out the best wine by country and province:</p>
                    <img src="../img/pandas-kaggle/groupwise-analysis-3.PNG" class="mx-auto d-block" alt="Groupwise analysis">
                    <p>Another groupby() method worth mentioning is <span class="badge rounded-pill bg-secondary">agg()</span>, which lets you run a bunch of different functions on your DataFrame simultaneously. We can generate a simple statistical summary of the dataset as follows:</p>
                    <img src="../img/pandas-kaggle/groupwise-analysis-4.PNG" class="mx-auto d-block" alt="Groupwise analysis">
                    <p>A multi-index differs from a regular index in that it has multiple levels:</p>
                    <img src="../img/pandas-kaggle/multi-indexes-1.PNG" class="mx-auto d-block" alt="Multi-indexes"><img src="../img/pandas-kaggle/multi-indexes-2.PNG" class="mx-auto d-block" alt="Multi-indexes">
                    <p>The multi-index method you will use most often is the one for converting back to a regular index, the <span class="badge rounded-pill bg-secondary">reset_index()</span> method:</p>
                    <img src="../img/pandas-kaggle/multi-indexes-3.PNG" class="mx-auto d-block" alt="Multi-indexes">
                    <p>Looking again at countries_reviewed we can see that grouping returns data in index order, not in value order. That is to say, when outputting the result of a groupby, the order of the rows is dependent on the values in the index, not in the data. To get data in the order want it in we can sort it ourselves. The <span class="badge rounded-pill bg-secondary">sort_values()</span> method is handy for this:</p>
                    <img src="../img/pandas-kaggle/sorting-1.PNG" class="mx-auto d-block" alt="Sorting"><img src="../img/pandas-kaggle/sorting-2.PNG" class="mx-auto d-block" alt="Sorting"><img src="../img/pandas-kaggle/sorting-3.PNG" class="mx-auto d-block" alt="Sorting"><img src="../img/pandas-kaggle/sorting-4.PNG" class="mx-auto d-block" alt="Sorting"><img src="../img/pandas-kaggle/grouping-and-sorting-exercise-4.PNG" class="mx-auto d-block" alt="Grouping and sorting - exercise"></div>
            </div>
        </div>
        <div class="accordion-item">
            <h2 class="accordion-header" id="headingFive">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseFive" aria-expanded="true" aria-controls="collapseFive">Data Types and Missing Values</button>
            </h2>
            <div id="collapseFive" class="accordion-collapse collapse" aria-labelledby="headingFive" data-bs-parent="#accordionExample">
                <div class="accordion-body"><img src="../img/pandas-kaggle/dtypes-1.PNG" class="mx-auto d-block" alt="Dtypes"><img src="../img/pandas-kaggle/dtypes-2.PNG" class="mx-auto d-block" alt="Dtypes">
                    <p>One peculiarity to keep in mind is that columns consisting entirely of strings do not get their own type; they are instead given the object type.</p>
                    <p>It's possible to convert a column of one type into another wherever such a conversion makes sense by using the <span class="badge rounded-pill bg-secondary">astype()</span> function. We may transform the points column from its existing int64 data type into a float64 data type:</p>
                    <img src="../img/pandas-kaggle/dtypes-3.PNG" class="mx-auto d-block" alt="Dtypes">
                    <p>Entries missing values are given the value NaN, short for "Not a Number". For technical reasons these NaN values are always of the float64 dtype. To select NaN entries you can use <span class="badge rounded-pill bg-secondary">pd.isnull()</span> (or its companion <span class="badge rounded-pill bg-secondary">pd.notnull()</span>):</p>
                    <img src="../img/pandas-kaggle/missing-data-1.PNG" class="mx-auto d-block" alt="Missing data"><img src="../img/pandas-kaggle/missing-data-2.PNG" class="mx-auto d-block" alt="Missing data">
                    <p>Alternatively, we may have a non-null value that we would like to replace. Suppose that since this dataset was published, reviewer Kerin O'Keefe has changed her Twitter handle from @kerinokeefe to @kerino:</p>
                    <img src="../img/pandas-kaggle/missing-data-3.PNG" class="mx-auto d-block" alt="Missing data">
                    <p>The <span class="badge rounded-pill bg-secondary">replace()</span> method is worth mentioning here because it's handy for replacing missing data which is given some kind of sentinel value in the dataset: things like "Unknown", "Undisclosed", "Invalid", and so on.</p>
                </div>
            </div>
        </div>
        <div class="accordion-item">
            <h2 class="accordion-header" id="headingSix">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSix" aria-expanded="true" aria-controls="collapseSix">Renaming and Combining</button>
            </h2>
            <div id="collapseSix" class="accordion-collapse collapse" aria-labelledby="headingSix" data-bs-parent="#accordionExample">
                <div class="accordion-body">
                    <p>The first function we'll introduce here is <span class="badge rounded-pill bg-secondary">rename()</span>, which lets you change index names and/or column names:</p>
                    <img src="../img/pandas-kaggle/renaming-1.PNG" class="mx-auto d-block" alt="Renaming"><img src="../img/pandas-kaggle/renaming-2.PNG" class="mx-auto d-block" alt="Renaming">
                    <p>You'll probably rename columns very often, but rename index values very rarely. For that, <span class="badge rounded-pill bg-secondary">set_index()</span> is usually more convenient.</p>
                    <p>Both the row index and the column index can have their own name attribute. The complimentary <span class="badge rounded-pill bg-secondary">rename_axis()</span> method may be used to change these names:</p>
                    <img src="../img/pandas-kaggle/renaming-3.PNG" class="mx-auto d-block" alt="Renaming"><img src="../img/pandas-kaggle/renaming-and-combining-exercise-1.PNG" class="mx-auto d-block" alt="Renaming and combining - exercise">
                    <p>The simplest combining method is <span class="badge rounded-pill bg-secondary">concat()</span>. This is useful when we have data in different DataFrame or Series objects but having the same fields (columns):</p>
                    <img src="../img/pandas-kaggle/combining-1.PNG" class="mx-auto d-block" alt="Combining">
                    <p>The middlemost combiner in terms of complexity is join(). <span class="badge rounded-pill bg-secondary">join()</span> lets you combine different DataFrame objects which have an index in common:</p>
                    <img src="../img/pandas-kaggle/combining-2.PNG" class="mx-auto d-block" alt="Combining"><img src="../img/pandas-kaggle/combining-3.PNG" class="mx-auto d-block" alt="Combining">
                    <p>The <span class="badge rounded-pill bg-secondary">lsuffix</span> and <span class="badge rounded-pill bg-secondary">rsuffix</span> parameters are necessary here because the data has the same column names in both British and Canadian datasets.</p>
                    <img src="../img/pandas-kaggle/renaming-and-combining-exercise-2.PNG" class="mx-auto d-block" alt="Renaming and combining - exercise"></div>
            </div>
        </div>
    </div>
</div>
<script src="../js/"></script> 
<script src="../js/bootstrap.min.js"></script>
</body>
</html>