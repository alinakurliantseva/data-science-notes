<!DOCTYPE html>
<html lang="en">
<head>
<title>Python for Data Analysis (Wes McKinney)</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="../img/favicon.ico">
<link rel="stylesheet" href="../css/bootstrap.min.css">
</head>
<body>
<div class="container">
    <h1 class="text-center mt-5 mb-5">Python for Data Analysis</h1>
    <p class="text-end mb-5"><em>Wes McKinney</em></p>
    <div class="accordion" id="accordionExample">
        <div class="accordion-item">
            <h2 class="accordion-header" id="headingOne">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">Python Language Basics, IPython, and Jupyter Notebooks</button>
            </h2>
            <div id="collapseOne" class="accordion-collapse collapse" aria-labelledby="headingOne" data-bs-parent="#accordionExample">
                <div class="accordion-body">
                    <p>Tab completion:</p>
                    <img src="../img/python-for-data-analysis/python-language-basics-ipython-and-jupyter-notebooks-1.PNG" class="mx-auto d-block" alt="Python Language Basics, IPython, and Jupyter Notebooks"><img src="../img/python-for-data-analysis/python-language-basics-ipython-and-jupyter-notebooks-2.PNG" class="mx-auto d-block" alt="Python Language Basics, IPython, and Jupyter Notebooks"><img src="../img/python-for-data-analysis/python-language-basics-ipython-and-jupyter-notebooks-3.PNG" class="mx-auto d-block" alt="Python Language Basics, IPython, and Jupyter Notebooks">
                    <p>When assigning a variable in Python, you are creating a <span class="badge rounded-pill bg-secondary">reference</span> to the object on the righthand side of the equals sign. In some languages, this assignment would cause the data [1, 2, 3] to be copied; in Python, a and b actually now refer to the same object, the original list [1, 2, 3]:</p>
                    <img src="../img/python-for-data-analysis/python-language-basics-ipython-and-jupyter-notebooks-4.PNG" class="mx-auto d-block" alt="Python Language Basics, IPython, and Jupyter Notebooks">
                    <p>When you pass objects as arguments to a function, new local variables are created referencing the original objects without any copying:</p>
                    <img src="../img/python-for-data-analysis/python-language-basics-ipython-and-jupyter-notebooks-5.PNG" class="mx-auto d-block" alt="Python Language Basics, IPython, and Jupyter Notebooks">
                    <p>To check if two references refer to the same object, use the <span class="badge rounded-pill bg-secondary">is</span> keyword. <span class="badge rounded-pill bg-secondary">is not</span> is also perfectly valid if you want to check that two objects are not the same:</p>
                    <img src="../img/python-for-data-analysis/python-language-basics-ipython-and-jupyter-notebooks-6.PNG" class="mx-auto d-block" alt="Python Language Basics, IPython, and Jupyter Notebooks">
                    <p>Since <span class="badge rounded-pill bg-secondary">list</span> always creates a new Python list (i.e., a copy), we can be sure that c is distinct from a. Comparing with <span class="badge rounded-pill bg-secondary">is</span> is not the same as the <span class="badge rounded-pill bg-secondary">==</span> operator, because in this case we have:</p>
                    <img src="../img/python-for-data-analysis/python-language-basics-ipython-and-jupyter-notebooks-7.PNG" class="mx-auto d-block" alt="Python Language Basics, IPython, and Jupyter Notebooks">
                    <p>A very common use of <span class="badge rounded-pill bg-secondary">is</span> and <span class="badge rounded-pill bg-secondary">is not</span> is to check if a variable is <span class="badge rounded-pill bg-secondary">None</span>, since there is only one instance of None:</p>
                    <img src="../img/python-for-data-analysis/python-language-basics-ipython-and-jupyter-notebooks-8.PNG" class="mx-auto d-block" alt="Python Language Basics, IPython, and Jupyter Notebooks">
                    <p><span class="badge rounded-pill bg-secondary">None</span> is a common default value for function arguments:</p>
                    <img src="../img/python-for-data-analysis/python-language-basics-ipython-and-jupyter-notebooks-9.PNG" class="mx-auto d-block" alt="Python Language Basics, IPython, and Jupyter Notebooks">
                    <p><span class="badge rounded-pill bg-secondary">pass</span> can be used in blocks where no action is to be taken (or as a placeholder for code not yet implemented); it is only required because Python uses whitespace to delimit blocks:</p>
                    <img src="../img/python-for-data-analysis/python-language-basics-ipython-and-jupyter-notebooks-10.PNG" class="mx-auto d-block" alt="Python Language Basics, IPython, and Jupyter Notebooks">
                    <p>The <span class="badge rounded-pill bg-secondary">range</span> function returns an iterator that yields a sequence of evenly spaced integers:</p>
                    <img src="../img/python-for-data-analysis/python-language-basics-ipython-and-jupyter-notebooks-11.PNG" class="mx-auto d-block" alt="Python Language Basics, IPython, and Jupyter Notebooks"><img src="../img/python-for-data-analysis/python-language-basics-ipython-and-jupyter-notebooks-12.PNG" class="mx-auto d-block" alt="Python Language Basics, IPython, and Jupyter Notebooks">
                    <p>Both a start, end, and step (which may be negative) can be given:</p>
                    <img src="../img/python-for-data-analysis/python-language-basics-ipython-and-jupyter-notebooks-13.PNG" class="mx-auto d-block" alt="Python Language Basics, IPython, and Jupyter Notebooks">
                    <p>As you can see, range produces integers up to but not including the endpoint. A common use of range is for iterating through sequences by index:</p>
                    <img src="../img/python-for-data-analysis/python-language-basics-ipython-and-jupyter-notebooks-14.PNG" class="mx-auto d-block" alt="Python Language Basics, IPython, and Jupyter Notebooks">
                    <p>A <span class="badge rounded-pill bg-secondary">ternary expression</span> in Python allows you to combine an if-else block that produces a value into a single line or expression:</p>
                    <img src="../img/python-for-data-analysis/python-language-basics-ipython-and-jupyter-notebooks-15.PNG" class="mx-auto d-block" alt="Python Language Basics, IPython, and Jupyter Notebooks"><img src="../img/python-for-data-analysis/python-language-basics-ipython-and-jupyter-notebooks-16.PNG" class="mx-auto d-block" alt="Python Language Basics, IPython, and Jupyter Notebooks"><img src="../img/python-for-data-analysis/python-language-basics-ipython-and-jupyter-notebooks-17.PNG" class="mx-auto d-block" alt="Python Language Basics, IPython, and Jupyter Notebooks"></div>
            </div>
        </div>
        <div class="accordion-item">
            <h2 class="accordion-header" id="headingTwo">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseTwo" aria-expanded="true" aria-controls="collapseTwo">Built-in Data Structures, Functions, and Files</button>
            </h2>
            <div id="collapseTwo" class="accordion-collapse collapse" aria-labelledby="headingTwo" data-bs-parent="#accordionExample">
                <div class="accordion-body">
                    <p>Unpacking tuples:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-1.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>Even sequences with nested tuples can be unpacked:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-2.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>To swap variable names:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-3.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>A common use of variable unpacking is iterating over sequences of tuples or lists:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-4.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>The Python language recently acquired some more advanced tuple unpacking to help with situations where you may want to "pluck" a few elements from the beginning of a tuple. This uses the special syntax <span class="badge rounded-pill bg-secondary">*rest</span>, which is also used in function signatures to capture an arbitrarily long list of positional arguments:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-5.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>This rest bit is sometimes something you want to discard; there is nothing special about the rest name. As a matter of convention, many Python programmers will use the underscore (_) for unwanted variables:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-6.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>Since the size and contents of a tuple cannot be modified, it is very light on instance methods. A particularly useful one (also available on lists) is <span class="badge rounded-pill bg-secondary">count</span>, which counts the number of occurrences of a value:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-7.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>Elements can be appended to the end of the list with the <span class="badge rounded-pill bg-secondary">append</span> method:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-8.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>Using <span class="badge rounded-pill bg-secondary">insert</span> you can insert an element at a specific location in the list:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-9.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>The inverse operation to insert is <span class="badge rounded-pill bg-secondary">pop</span>, which removes and returns an element at a particular index:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-10.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>Elements can be removed by value with <span class="badge rounded-pill bg-secondary">remove</span>, which locates the first such value and removes it from the last:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-11.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>Check if a list contains a value using the <span class="badge rounded-pill bg-secondary">in</span> keyword:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-12.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>The keyword <span class="badge rounded-pill bg-secondary">not</span> can be used to negate <span class="badge rounded-pill bg-secondary">in</span>:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-13.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>If you have a list already defined, you can append multiple elements to it using the <span class="badge rounded-pill bg-secondary">extend</span> method:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-14.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>You can sort a list in-place (without creating a new object) by calling its <span class="badge rounded-pill bg-secondary">sort</span> function:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-15.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>You can select sections of most sequence types by using slice notation, which in its basic form consists of <span class="badge rounded-pill bg-secondary">start:stop</span> passed to the indexing operator []:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-16.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>Slices can also be assigned to with a sequence:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-17.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>While the element at the start index is included, the stop index is not included, so that the number of elements in the result is <span class="badge rounded-pill bg-secondary">stop - start</span>.</p>
                    <p>Either the start or stop can be omitted, in which case they default to the start of the sequence and the end of the sequence, respectively:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-18.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>Negative indices slice the sequence relative to the end:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-19.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>A <span class="badge rounded-pill bg-secondary">step</span> can also be used after a second colon to, say, take every other element:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-20.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files"><img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-21.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>Itâ€™s common when iterating over a sequence to want to keep track of the index of the current item:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-22.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>Since this is so common, Python has a built-in function, <span class="badge rounded-pill bg-secondary">enumerate</span>, which returns a sequence of (i, value) tuples:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-23.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files"><img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-24.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files"><img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-25.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>The <span class="badge rounded-pill bg-secondary">sorted</span> function returns a new sorted list from the elements of any sequence:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-26.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files"><img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-27.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files"><img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-28.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>You can check if a dict contains a key using the same syntax used for checking whether a list or tuple contains a value:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-29.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>You can delete values either using the <span class="badge rounded-pill bg-secondary">del</span> keyword or the <span class="badge rounded-pill bg-secondary">pop</span> method (which simultaneously returns the value and deletes the key):</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-30.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>The <span class="badge rounded-pill bg-secondary">keys</span> and <span class="badge rounded-pill bg-secondary">values</span> method give you iterators of the dict's keys and values, respectively:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-31.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files"><img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-32.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>You can merge one dict into another using the <span class="badge rounded-pill bg-secondary">update</span> method:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-33.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>A <span class="badge rounded-pill bg-secondary">list comprehension</span> looks like this:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-34.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files"><img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-35.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files"><img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-36.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>A <span class="badge rounded-pill bg-secondary">dict comprehension</span> looks like this:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-37.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files"><img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-38.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>There is no issue with having multiple <span class="badge rounded-pill bg-secondary">return</span> statements. If Python reaches the end of a function without encountering a return statement, <span class="badge rounded-pill bg-secondary">None</span> is returned automatically.</p>
                    <p>Each function can have <span class="badge rounded-pill bg-secondary">positional</span> arguments and <span class="badge rounded-pill bg-secondary">keyword</span> arguments. Keyword arguments are most commonly used to specify default values or optional arguments. In the preceding function, x and y are positional arguments while z is a keyword argument. This means that the function can be called in any of these ways:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-39.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>The main restriction on function arguments is that the keyword arguments must follow the positional arguments (if any).</p>
                    <p>It is possible to use keywords for passing positional arguments as well:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-40.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files">
                    <p>To declare an anonymous (<span class="badge rounded-pill bg-secondary">lambda</span>) function:</p>
                    <img src="../img/python-for-data-analysis/built-in-data-structures-functions-and-files-41.PNG" class="mx-auto d-block" alt="Built-in Data Structures, Functions, and Files"></div>
            </div>
        </div>
        <div class="accordion-item">
            <h2 class="accordion-header" id="headingThree">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseThree" aria-expanded="true" aria-controls="collapseThree">NumPy Basics: Arrays and Vectorized Computation</button>
            </h2>
            <div id="collapseThree" class="accordion-collapse collapse" aria-labelledby="headingThree" data-bs-parent="#accordionExample">
                <div class="accordion-body">
                    <p>The easiest way to create an array is to use the <span class="badge rounded-pill bg-secondary">array</span> function:</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-1.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p>Nested sequences, like a list of equal-length lists, will be converted into a multidimensional array:</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-2.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p><span class="badge rounded-pill bg-secondary">zeros</span> and <span class="badge rounded-pill bg-secondary">ones</span> create arrays of 0s or 1s, respectively, with a given length or shape, <span class="badge rounded-pill bg-secondary">empty</span> creates an array without initializing its values to any particular value:</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-3.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation"><img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-4.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p>It's not safe to assume that np.empty will return an array of all zeros. In some cases, it may return uninitialized "garbage" values.</p>
                    <p>You can explicitly convert or cast an array from one dtype to another using ndarray's <span class="badge rounded-pill bg-secondary">astype</span> method:</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-5.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p>Calling astype always creates a new array (a copy of the data), even if the new dtype is the same as the old dtype.</p>
                    <p>Arrays are important because they enable you to express batch operations on data without writing any for loops. NumPy users call this <span class="badge rounded-pill bg-secondary">vectorization</span>.</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-6.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation"><img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-7.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation"><img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-8.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p>Array slices are <span class="badge rounded-pill bg-secondary">views</span> on the original array; this means that the data is not copied, and any modifications to the view will be reflected in the source array:</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-9.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation"><img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-10.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation"><img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-11.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p>The "bare" slice [:] will assign to all values in an array:</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-12.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p>As NumPy has been designed to be able to work with very large arrays, you could imagine performance and memory problems if NumPy insisted on always copying data. If you want a copy of a slice of an ndarray instead of a view, you will need to explicitly copy the array - for example, <span class="badge rounded-pill bg-secondary">arr[5:8].copy()</span>.</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-13.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation"><img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-14.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation"><img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-15.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation"><img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-16.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation"><img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-17.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p>This expression is the same as though we had indexed in two steps:</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-18.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p>You can pass multiple slices just like you can pass multiple indexes:</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-19.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation"><img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-20.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation"><img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-21.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation"><img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-22.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p>Suppose each name corresponds to a row in the data array and we wanted to select all the rows with corresponding name "Bob". Like arithmetic operations, comparisons (such as ==) with arrays are also <span class="badge rounded-pill bg-secondary">vectorized</span>. Thus, comparing names with the string "Bob" yields a boolean array:</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-23.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p>This boolean array can be passed when indexing the array:</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-24.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation"><img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-25.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p>To select everything but "Bob", you can either use <span class="badge rounded-pill bg-secondary">!=</span> or negate the condition using <span class="badge rounded-pill bg-secondary">~</span>:</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-26.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p>The <span class="badge rounded-pill bg-secondary">~</span> operator can be useful when you want to invert a general condition:</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-27.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p>Selecting two of the three names to combine multiple boolean conditions, use boolean arithmetic operators like <span class="badge rounded-pill bg-secondary">&amp;</span> (and) and <span class="badge rounded-pill bg-secondary">|</span> (or):</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-28.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p>Selecting data from an array by boolean indexing always creates a copy of the data, even if the returned array is unchanged.</p>
                    <p>Setting values with boolean arrays works in a common-sense way. To set all of the negative values in data to 0 we need only do:</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-29.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p>Setting whole rows or columns using a one-dimensional boolean array is also easy:</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-30.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p>A universal function, or <span class="badge rounded-pill bg-secondary">ufunc</span>, is a function that performs element-wise operations on data in ndarrays.</p>
                    <p>Many ufuncs are simple element-wise transformations, like <span class="badge rounded-pill bg-secondary">sqrt</span> or <span class="badge rounded-pill bg-secondary">exp</span>. These are referred to as <span class="badge rounded-pill bg-secondary">unary</span> ufuncs:</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-31.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p>Others, such as <span class="badge rounded-pill bg-secondary">add</span> or <span class="badge rounded-pill bg-secondary">maximum</span>, take two arrays (thus, <span class="badge rounded-pill bg-secondary">binary</span> ufuncs) and return a single array as the result:</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-32.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p>The <span class="badge rounded-pill bg-secondary">numpy.where</span> function is a vectorized version of the ternary expression <span class="badge rounded-pill bg-secondary">x if condition else y</span>:</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-33.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p>Suppose we wanted to take a value from xarr whenever the corresponding value in cond is True, and otherwise take the value from yarr. A list comprehension doing this might look like:</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-34.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p>This has multiple problems. First, it will not be very fast for large arrays (because all the work is being done in interpreted Python code). Second, it will not work with multidimensional arrays. With np.where you can write this very concisely:</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-35.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p>The second and third arguments to np.where don't need to be arrays; one or both of them can be scalars. A typical use of where in data analysis is to produce a new array of values based on another array. Suppose you had a matrix of randomly generated data and you wanted to replace all positive values with 2 and all negative values with -2:</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-36.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation"><img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-37.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p>You can combine scalars and arrays when using np.where:</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-38.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p>A set of mathematical functions that compute statistics about an entire array or about the data along an axis are accessible as methods of the array class. You can use aggregations (often called <span class="badge rounded-pill bg-secondary">reductions</span>) like sum, mean, and std (standard deviation) either by calling the array instance method or using the top-level NumPy function:</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-39.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p>Functions like mean and sum take an optional axis argument that computes the statistic over the given <span class="badge rounded-pill bg-secondary">axis</span>, resulting in an array with one fewer dimension:</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-40.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p>Here, arr.mean(1) means "compute mean across the columns" where arr.sum(0) means "compute sum down the rows".</p>
                    <p>Boolean values are coerced to 1 (True) and 0 (False) in the preceding methods. Thus, <span class="badge rounded-pill bg-secondary">sum</span> is often used as a means of counting True values in a boolean array:</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-41.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p>There are two additional methods, <span class="badge rounded-pill bg-secondary">any</span> (tests whether one or more values in an array is True) and <span class="badge rounded-pill bg-secondary">all</span> (checks if every value is True), useful especially for boolean arrays:</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-42.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p>These methods also work with non-boolean arrays, where non-zero elements evaluate to True.</p>
                    <p>NumPy has some basic set operations for one-dimensional ndarrays. A commonly used one is <span class="badge rounded-pill bg-secondary">np.unique</span>, which returns the sorted unique values in an array:</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-43.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation">
                    <p>Another function, <span class="badge rounded-pill bg-secondary">np.in1d</span>, tests membership of the values in one array in another, returning a boolean array:</p>
                    <img src="../img/python-for-data-analysis/numpy-basics-arrays-and-vectorized-computation-44.PNG" class="mx-auto d-block" alt="NumPy Basics: Arrays and Vectorized Computation"></div>
            </div>
        </div>
        <div class="accordion-item">
            <h2 class="accordion-header" id="headingFour">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseFour" aria-expanded="true" aria-controls="collapseFour">Getting Started with pandas</button>
            </h2>
            <div id="collapseFour" class="accordion-collapse collapse" aria-labelledby="headingFour" data-bs-parent="#accordionExample">
                <div class="accordion-body"></div>
            </div>
        </div>
        <div class="accordion-item">
            <h2 class="accordion-header" id="headingFive">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseFive" aria-expanded="true" aria-controls="collapseFive">Data Loading, Storage, and File Formats</button>
            </h2>
            <div id="collapseFive" class="accordion-collapse collapse" aria-labelledby="headingFive" data-bs-parent="#accordionExample">
                <div class="accordion-body"></div>
            </div>
        </div>
    </div>
</div>
<script src="../js/"></script> 
<script src="../js/bootstrap.min.js"></script>
</body>
</html>